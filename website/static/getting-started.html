<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="十分钟入门 MobX & React">

    <link rel="stylesheet" href="assets/getting-started-assets/style.css" />
    <link href='https://fonts.googleapis.com/css?family=PT+Serif' rel='stylesheet' type='text/css'>

    <link rel="shortcut icon" type="image/png" href="assets/getting-started-assets/images/favicon.png" />

    <title>十分钟入门 MobX & React</title>
</head>

<body>
    <div class="github-fork-ribbon-wrapper right-bottom fixed">
        <div class="github-fork-ribbon">
            <a href="https://github.com/mobxjs/mobx">Fork me on GitHub</a>
        </div>
    </div>
    <table class="root">
        <tr>
            <td class="left">
              <div class="left-content-wrapper">
                <div class="left-content">
                    <header>
                        <a href="index.html" style="float:left">
                        <img style="width: 120px; padding-right: 20px;" src="assets/getting-started-assets/images/mobservable.png" id="logo" /></a>
                        <h1 id="project_title">MobX</h1>
                        <h2 id="project_tagline" style="font-size: 18pt">十分钟入门 MobX & React</h2>
                        <hr/>
                    </header>

                    <section id="main_content">
                        <p>
                            <a href="https://github.com/mobxjs/mobx"><code>MobX</code></a> 是一种简单、可扩展而且身经百战的状态管理解决方案。这个教程会在十分钟之内教给你 MobX 中所有的重要概念。MobX 是一个独立的库，但大多数人都把它和 React 放在一起使用，那么这个教程就着重介绍这个组合。
                        </p>
                        <h3>核心理念</h3>
                        <p>
                            状态是每个应用的核心。想要创建出 bug 丛生而且难以管理的应用程序，那么再没有一种方法比搞出不一致的状态或者与各种局部变量不同步的状态更快了。因此，许多状态管理解决方案会通过比如使状态不可变来试图限制你修改状态的方式。但这样就会引出新的问题；数据需要被规范化、引用的完整性无法得到保证，而且万一你喜欢像类这样功能强大的概念的话，那你几乎没办法再用到它们。
                        </p>
                        <p>
                            MobX 通过解决根本问题让状态管理又一次变得简单了：它让不一致的状态不再可能出现。要做到这一点，策略很简单： <em>要确保从应用状态中派生出的一切都将被自动派生</em> 。
                        </p>
                        <p>
                            从概念上讲， MobX 会把你的应用程序视为一份电子表格。
                        <p>
                            <img src="assets/getting-started-assets/overview.png" width="100%" />
                        <ol>
                            <li>
                                首先是 <em>应用状态</em> 。就是那些呈图状结构分布、组成你应用状态模型的对象、数组、原始值和引用。这些值是你应用中的&ldquo;单元格&rdquo;。
                            </li>
                            <li>
                                其次是 <em>派生</em> 。也就是任何可以从你的应用状态中被自动计算出来的值。这些派生——或者叫计算值——可以是简单的值，比如未完成待办事项的个数；也可以是复杂的东西，比如你待办清单的 HTML 视觉表示。
                            </li>
                            <li>
                                <em>反应</em> 与派生非常相似。但主要的区别在于这些函数不会返回值，而是会自动执行一些任务。通常这些任务与 I/O 有关。它们会用来确保 DOM 的更新或者在对的时间自动发出网络请求。
                            </li>
                            <li>
                                最后是 <em>动作</em> 。动作就是所有能修改状态的东西。MobX 会确保所有由于你的动作而引起的应用状态的改变都将被所有派生和反应同步而顺畅地自动处理掉。
                            </li>
                        </ol>
                        <h3>一个简单的待办事项 store...</h3>
                        <p>
                            理论已经够多了，与其仔细阅读上面的东西，看一下实际的操作可能会带来出更好的理解。为了原创性，我们就从一个简单的待办事项 store 开始。注意，以下所有的代码块都是可以编辑的，也可以用 <em>运行代码</em> 按钮运行。下面是一个非常简单直白的待办事项 store <code>TodoStore</code> ，里面装着一个待办事项集合。暂时还没有 MobX 什么事儿。
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code1" rows="25">
class TodoStore {
  todos = [];

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  report() {
    if (this.todos.length === 0)
      return "<无>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `下一个待办："${nextTodo ? nextTodo.task : "<无>"}"。 ` +
      `进度：${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const todoStore = new TodoStore();
                        </textarea>
                        <p>
                            我们刚刚创建了一个带有待办事项 <code>todos</code> 集合的 <code>todoStore</code> 实例。是时候往 <code>TodoStore</code> 里装些对象了。为了让我们能够看到更改的效果，我们在每次更改后调用 <code>todoStore.report</code> 把它打印出来。注意，这个报告会一直故意只打印第一个任务。这会让这个例子有点假，但我们稍后会看到这样的话可以很好地展示 MobX 依赖追踪的动态性。
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code2" rows="15">
todoStore.addTodo("阅读 MobX 教程");
console.log(todoStore.report());

todoStore.addTodo("试用 MobX");
console.log(todoStore.report());

todoStore.todos[0].completed = true;
console.log(todoStore.report());

todoStore.todos[1].task = "在自己的项目中试用 MobX";
console.log(todoStore.report());

todoStore.todos[0].task = "理解 MobX 教程";
console.log(todoStore.report());
                        </textarea>
                        <button onClick="runCode(['#code1', '#code2'])" class="btn-run">运行代码</button>

                        <h3>变成响应式</h3>
                        <p>
                            到目前为止，这段代码并没有什么特别之处。但如果我们不用非得刻意调用 <code>report</code> ，而是规定它必须在每次 <em>相关</em> 状态改变时被调用呢？那样的话我们就不需要从代码中所有 <em>有可能</em> 对报告有影响的地方手动来调用 <code>report</code> 了。我们确实想让最新的报告被打印出来，但我们并不想因为要去手动组织它而费功夫。
                        </p>
                        <p>
                            幸运的是，这正是 MobX 能为我们做到的事情——自动执行只依赖于状态的代码。这样的话，我们的 <code>report</code> 函数就会自动更新，就像电子表格里的一个图表一样。为了做到这一点，<code>TodoStore</code> 就必须变成可观察的，这样 MobX 就可以追踪到所有正在进行的更改。我们来改一下这个类，从而刚好可以实现这一点。
                        </p>
                        <p>
                            还有，<code>completedTodosCount</code> 属性可以自动从待办清单中派生出来。通过使用 <code>observable</code> 和 <code>computed</code> 注解，我们可以为一个对象引入可观察属性。
                            在下面的例子里我们使用了 <code>makeObservable</code> 来刻意地展示出注解，但我们其实也可以使用 <code>makeAutoObservable(this)</code> 以便简化这个过程。
                        </p>
                        <textarea spellcheck="false" class="prettyprint" id="code3" rows="8">
class ObservableTodoStore {
  todos = [];
  pendingRequests = 0;

  constructor() {
    makeObservable(this, {
      todos: observable,
      pendingRequests: observable,
      completedTodosCount: computed,
      report: computed,
      addTodo: action,
    });
    autorun(() => console.log(this.report));
  }

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  get report() {
    if (this.todos.length === 0)
      return "<无>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `Next todo: "${nextTodo ? nextTodo.task : "<无>"}". ` +
      `Progress: ${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const observableTodoStore = new ObservableTodoStore();
                        </textarea>

                        <p>That's it! We marked some properties as being <code>observable</code> to signal MobX that these values can change over time.
                            The computations are decorated with <code>computed</code> to identify that these can be derived from the state and caches as long as no underlying state changed.
                        </p>
                        <p>
                            The <code>pendingRequests</code> and <code>assignee</code> attributes are not used so far,
                            but will be used later in this tutorial.
                        </p>
                        <p>
                            In the constructor we created a small function that prints the <code>report</code> and
                            wrapped it in <code>autorun</code>. Autorun creates a <em>reaction</em> that runs once, and after
                            that automatically re-runs whenever any observable data that was used inside the function changes.
                            Because <code>report</code> uses the observable <code>todos</code> property, it will print the
                            report whenever appropriate. This is demonstrated in the next listing. Just press the <em>run</em> button:
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code4" rows="6">
observableTodoStore.addTodo("read MobX tutorial");
observableTodoStore.addTodo("try MobX");
observableTodoStore.todos[0].completed = true;
observableTodoStore.todos[1].task = "try MobX in own project";
observableTodoStore.todos[0].task = "grok MobX tutorial";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4'])" class="btn-run">Run code</button>

                        <p>Pure fun, right? The <code>report</code> did print automatically, synchronously and without leaking
                            intermediate values. If you investigate the log carefully, you will see that the fifth line
                            didn't result in a new log-line. Because the report did not <em>actually</em> change as a result
                            of the rename, although the backing data did. On the other hand, changing the name of the first
                            todo did update the report, since that name is actively used in the report.
                            This demonstrates nicely that
                            not just the <code>todos</code> array is being observed by the <code>autorun</code>, but also
                            the individual properties inside the todo items.
                        </p>
                        <h3 id="reactive-reactjs-components">Making React reactive</h3>
                        <p>Ok, so far we made a silly report reactive. Time to build a reactive user interface around this very
                            same store. React components are (despite their name) not reactive out of the box.
                            The <code>observer</code> HoC wrapper from the <code>mobx-react-lite</code> package fixes that by
                            basically wrapping the React component in <code>autorun</code>. To automatically
                            keep components in sync with the state. This is conceptually not different from what we did
                            with the <code>report</code> before.
                        </p>
                        <p>
                            The next listing defines a few React components.
                            The only MobX specific code in there is the <code>observer</code> wrapping.
                            That is enough to make sure that each component individually re-renders when relevant data changes.
                            We don't have to call state <code>useState</code> setters anymore,
                            nor do we have to figure out how to subscribe to the proper parts
                            of the application state using selectors or higher order components that need configuration.
                            Basically, all components have become smart. Yet they are defined in a dumb, declarative manner.
                        </p>
                        <p>
                            Press the <em>Run code</em> button to see the code below in action. The listing is editable so
                            feel free to play with it. Try for example to remove all the <code>observer</code> calls, or
                            just the one decorating the <code>TodoView</code>. The numbers in the preview on the right highlight
                            how often a component is rendered.
                        </p>
                        <textarea spellcheck="false" class="" id="react1" rows="44">
const TodoList = observer(({store}) => {
  const onNewTodo = () => {
    store.addTodo(prompt('Enter a new todo:','coffee plz'));
  }

  return (
    <div>
      { store.report }
      <ul>
        { store.todos.map(
          (todo, idx) => <TodoView todo={ todo } key={ idx } />
        ) }
      </ul>
      { store.pendingRequests > 0 ? <marquee>Loading...</marquee> : null }
      <button onClick={ onNewTodo }>New Todo</button>
      <small> (double-click a todo to edit)</small>
      <RenderCounter />
    </div>
  );
})

const TodoView = observer(({todo}) => {
  const onToggleCompleted = () => {
    todo.completed = !todo.completed;
  }

  const onRename = () => {
    todo.task = prompt('Task name', todo.task) || todo.task;
  }

  return (
    <li onDoubleClick={ onRename }>
      <input
        type='checkbox'
        checked={ todo.completed }
        onChange={ onToggleCompleted }
      />
      { todo.task }
      { todo.assignee
        ? <small>{ todo.assignee.name }</small>
        : null
      }
      <RenderCounter />
    </li>
  );
})

ReactDOM.render(
  <TodoList store={ observableTodoStore } />,
  document.getElementById('reactjs-app')
);
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1'])" class="btn-run">Run code</button>

                        <p>
                            The next listing nicely demonstrates that we only have to alter the data, without doing any further bookkeeping.
                            MobX will automatically derive and update the relevant parts of the user interface again from the state in the store.
                        </p>

                        <textarea spellcheck="false" class="" id="play1" rows="8">
const store = observableTodoStore;
store.todos[0].completed = !store.todos[0].completed;
store.todos[1].task = "Random todo " + Math.random();
store.todos.push({ task: "Find a fine cheese", completed: true });
// etc etc.. add your own statements here...
                        </textarea>
                        <button onClick="if (typeof observableTodoStore === 'undefined') { runCode(['#code1', '#code3', '#code4', '#react1']) } runCode(['#play1'])"
                        class="btn-run">Run code</button>
                        <button id="runline-btn" onClick="runCodePerLine()" class="btn-run">Run line-by-line</button>
                        <p>&nbsp;</p>

                        <h3>Working with references</h3>
                        <p>
                            So far we have created observable objects (both prototyped and plain objects), arrays and primitives. You might be wondering,
                            how are references handled in MobX? Is my state allowed to form a graph? In the previous listings
                            you might have noticed that there is an <code>assignee</code> property
                            on the todos. Let's give them some values by introducing another &ldquo;store&rdquo; (ok, it's just
                            a glorified array) containing people, and assign tasks to them.
                        </p>
                        <textarea spellcheck="false" class="" id="store2" rows="8">
const peopleStore = observable([
  { name: "Michel" },
  { name: "Me" }
]);
observableTodoStore.todos[0].assignee = peopleStore[0];
observableTodoStore.todos[1].assignee = peopleStore[1];
peopleStore[0].name = "Michel Weststrate";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1', '#store2'])" class="btn-run">Run code</button>
                        <p>We now have two independent stores. One with people and one with todos. To assign an <code>assignee</code>
                            to a person from the people store, we just assigned a reference. These changes will be picked
                            up automatically by the <code>TodoView</code>. With MobX there is no need to normalize data first
                            and to write selectors to make sure our components will be updated. In fact, it doesn't even
                            matter where the data is stored. As long as objects are made <em>observable</em>, MobX will be
                            able to track them. Real JavaScript references will just work. MobX will track them automatically
                            if they are relevant for a derivation. To test that, just try changing your name in the next
                            input box (make sure you have pressed the above <em>Run code</em> button first!).
                        </p>
                        <hr/>
                        <p style="text-align:center">Your name:
                            <input onkeyup="peopleStore[1].name = event.target.value" />
                        </p>
                        <hr/>
                        <p>By the way, the HTML of the above input box is simply: <pre>&lt;input onkeyup="peopleStore[1].name = event.target.value" /&gt;</pre></p>

                        <h3>Asynchronous actions</h3>
                        <p>Since everything in our small Todo application is derived from the state, it really doesn't matter <em>when</em> state is changed.
                            That makes creating asynchronous actions really straightforward.
                            Just press the the following button (multiple times) to emulate asynchronously loading new todo items:
                        </p>
                        <hr/>
                        <p style="text-align:center">
                            <button onclick="observableTodoStore.pendingRequests++; setTimeout(function() { observableTodoStore.addTodo('Random Todo ' + Math.random()); observableTodoStore.pendingRequests--;  }, 2000);">Load todo</button>
                        </p>
                        <hr/>
                        <p>The code behind that is really straightforward.
                            We start with updating the store property <code>pendingRequests</code> to have the UI reflect the current loading status.
                            Once loading is finished, we update the todos of the store and decrease the <code>pendingRequests</code> counter again.
                            Just compare this snippet with the earlier <code>TodoList</code> definition to see how the pendingRequests property is used.
                        </p><p>
                            Note that the timeout function is wrapped in <code>action</code>. This isn't strictly necessary,
                            but it makes sure that both mutations are processed in a single transaction, making sure any observers are only notified after both updates have completed.
<pre>observableTodoStore.pendingRequests++;
setTimeout(action(() => {
  observableTodoStore.addTodo('Random Todo ' + Math.random());
  observableTodoStore.pendingRequests--;
}), 2000);</pre>
                        </p>

                        <h3>Conclusion</h3>
                        <p>
                            That's all! No boilerplate. Just some simple, declarative components that form our complete UI. And which are derived completely,
                            reactively from our state. You are now ready to start using the <code>mobx</code> and <code>mobx-react-lite</code> packages in your own applications.
                            A short summary of the things you learned so far:
                        </p>
                        <ol>
                            <li>
                                Use the <code>observable</code> decorator or <code>observable(object or array)</code> functions to make objects trackable for MobX.
                            </li>
                            <li>
                                The <code>computed</code> decorator can be used to create functions that can automatically derive value from the state and cache them.
                            </li>
                            <li>
                                Use <code>autorun</code> to automatically run functions that depend on some observable state.
                                This is useful for logging, making network requests, etc.
                            </li>
                            <li>
                                Use the <code>observer</code> wrapper from the <code>mobx-react-lite</code> package to make your React components truly reactive.
                                They will update automatically and
                                efficiently. Even when used in large complex applications with large amounts of data.
                            </li>
                        </ol>
                        <p>
                            Feel free to play around a bit longer with the editable code blocks above to get a basic feeling how MobX reacts to all your
                            changes. You could for example add a log statement to the <code>report</code> function to see when it is called.
                            Or don't show the <code>report</code> at all and see how that
                            influences the rendering of the <code>TodoList</code>. Or show it only under specific circumstances...
                        </p>

                        <h3>MobX doesn't dictate architecture</h3>
                        <p>
                          Please note that the above examples are contrived and it is recommended to use proper engineering practices like
                            encapsulating logic in methods, organize them in stores or controllers, view-models etc.
                            Many different architectural patterns can be applied, and some are further discussed inside the official docs.
                            The above examples, and the examples in the official documentation show how MobX <em>could</em> be used, not how it <em>must</em> be used.
                            Or, as somebody on HackerNews put it:
                            <blockquote><em>
&ldquo;MobX, it's been mentioned elsewhere but I can't help but sing its praises.
Writing in MobX means that using controllers/ dispatchers/ actions/ supervisors or another form of managing dataflow returns to being an architectural concern you can pattern to your application's needs,
rather than being something that's required by default for anything more than a Todo app.&rdquo;
                            </em></blockquote>
                        </p>

                        <div style="text-align:center;">
                            <a class="github-button" href="https://github.com/mobxjs/mobx" data-icon="octicon-star" data-style="small" data-count-href="/mobxjs/mobx/stargazers"
                            data-count-api="/repos/mobxjs/mobx#stargazers_count" data-count-aria-label="# stargazers on GitHub"
                            aria-label="Star mobxjs/mobx on GitHub">Star</a>
                            <a href="https://twitter.com/share" class="twitter-share-button" data-via="mweststrate" data-hashtags="mobx">Tweet</a>
                        </div>

                    </section>

                    <footer>
                        <p class="copyright">MobX 由 <a href="https://twitter.com/mweststrate">mweststrate</a> 维护</p>
                    </footer>
                </div>
              </div>
            </td>
            <td class="right">
                <div class="right-content">
                    <h3>React 预览</h3>
                    <div id="reactjs-app">
                        <p style="text-align: center">接着读下去并按下你所遇到的 <em>运行</em> 按钮！</p>
                    </div>
                    <hr/>
                    <h3>控制台打印
                        <button onclick="clearConsole();" id="clear-btn">清除</button>
                    </h3>
                    <div id="consoleout"></div>
                </div>
            </td>
        </tr>
    </table>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.min.css" />
    <script src="assets/getting-started-assets/javascripts/jquery-2.1.4.min.js"></script>
    <script src="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/theme/xq-light.css">
    <script src="assets/getting-started-assets/javascripts/codemirror/javascript/javascript.js"></script>

    <script src="https://unpkg.com/react@16.13.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.13.1/umd/react-dom.development.js"></script>
    <script src="assets/getting-started-assets/babel.min.js"></script>
    <script src="https://unpkg.com/mobx@6.0.0-rc.8/dist/mobx.umd.development.js"></script>
    <script src="https://unpkg.com/mobx-react-lite@3.0.0-beta.1/dist/mobxreactlite.umd.development.js"></script>
    <script src="assets/getting-started-assets/script.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-65632006-1");
          pageTracker._trackPageview();
        } catch(err) {}
    </script>
    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    <script>
        !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>
</body>

</html>
