<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="十分钟入门 MobX & React">

    <link rel="stylesheet" href="assets/getting-started-assets/style.css" />
    <link href='https://fonts.googleapis.com/css?family=PT+Serif' rel='stylesheet' type='text/css'>

    <link rel="shortcut icon" type="image/png" href="assets/getting-started-assets/images/favicon.png" />

    <title>十分钟入门 MobX & React</title>
</head>

<body>
    <div class="github-fork-ribbon-wrapper right-bottom fixed">
        <div class="github-fork-ribbon">
            <a href="https://github.com/mobxjs/mobx">Fork me on GitHub</a>
        </div>
    </div>
    <table class="root">
        <tr>
            <td class="left">
              <div class="left-content-wrapper">
                <div class="left-content">
                    <header>
                        <a href="index.html" style="float:left">
                        <img style="width: 120px; padding-right: 20px;" src="assets/getting-started-assets/images/mobservable.png" id="logo" /></a>
                        <h1 id="project_title">MobX</h1>
                        <h2 id="project_tagline" style="font-size: 18pt">十分钟入门 MobX & React</h2>
                        <hr/>
                    </header>

                    <section id="main_content">
                        <p>
                            <a href="https://github.com/mobxjs/mobx"><code>MobX</code></a> 是一种简单、可扩展而且身经百战的状态管理解决方案。这个教程会在十分钟之内教给你 MobX 中所有的重要概念。MobX 是一个独立的库，但大多数人都把它和 React 放在一起使用，那么这个教程就着重介绍这个组合。
                        </p>
                        <h3>核心理念</h3>
                        <p>
                            状态是每个应用的核心。如果你想创建出 bug 丛生而且难以管理的应用程序，那么再没有比搞出不一致的状态或者与各种局部变量不同步的状态更快的方法了。因此，许多状态管理解决方案会通过比如使状态不可变来试图限制你修改状态的方式。但这样就会引出新的问题；数据需要被规范化、引用的完整性无法得到保证，而且万一你喜欢像类这样功能强大的概念的话，那你几乎没办法再用到它们。
                        </p>
                        <p>
                            MobX 通过解决根本问题让状态管理又一次变得简单起来：它让不一致的状态不再可能出现。要做到这一点，策略很简单： <em>要确保从应用状态中派生出的一切都将被自动派生出来</em> 。
                        </p>
                        <p>
                            从概念上讲， MobX 会把你的应用程序视为一份电子表格。
                        <p>
                            <img src="assets/getting-started-assets/overview.png" width="100%" />
                        <ol>
                            <li>
                                首先是 <em>应用状态</em> 。就是那些呈图状结构分布、组成你应用状态模型的对象、数组、原始值和引用。这些值是你应用中的&ldquo;单元格&rdquo;。
                            </li>
                            <li>
                                其次是 <em>derivation</em> 。也就是任何可以从你的应用状态中被自动计算出来的值。这些 derivation ——或者叫 computed ——可以是简单的值，比如未完成待办事项的个数；也可以是复杂的东西，比如你待办清单的 HTML 视觉表示。
                            </li>
                            <li>
                                <em>Reaction</em> 与 derivation 非常相似。但主要的区别在于这些函数不会返回值，而是会自动执行一些任务。通常这些任务与 I/O 有关。它们会用来确保 DOM 的更新或者在对的时间自动发出网络请求。
                            </li>
                            <li>
                                最后是 <em>action</em> 。action 就是所有能修改状态的东西。MobX 会确保所有由你的 action 而引发的应用状态改变都被所有的 derivation 和 reaction 同步而顺畅地自动处理掉。
                            </li>
                        </ol>
                        <h3>一个简单的待办事项 store...</h3>
                        <p>
                            理论已经够多了，与其仔细阅读上面的东西，看看实际的操作可能会带来出更好的理解。为了原创性，我们就从一个简单的待办事项 store 开始。注意，以下所有的代码块都是可以编辑的，也可以用 <em>运行代码</em> 按钮运行。下面是一个非常简单直白的待办事项 store <code>TodoStore</code> ，里面装着一个待办事项集合。暂时还没有 MobX 什么事儿。
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code1" rows="25">
class TodoStore {
  todos = [];

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  report() {
    if (this.todos.length === 0)
      return "<无>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `下一个待办："${nextTodo ? nextTodo.task : "<无>"}"。 ` +
      `进度：${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const todoStore = new TodoStore();
                        </textarea>
                        <p>
                            我们刚刚创建了一个带有待办事项 <code>todos</code> 集合的 <code>todoStore</code> 实例。是时候往 <code>TodoStore</code> 里装些对象了。为了看到更改的效果，我们在每次更改后都调用 <code>todoStore.report</code> 把它打印出来。注意，这个报告会一直故意只打印第一个任务。这会让这个例子有点假，但我们稍后会看到这样的话可以很好地展示 MobX 依赖追踪的动态性。
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code2" rows="15">
todoStore.addTodo("阅读 MobX 教程");
console.log(todoStore.report());

todoStore.addTodo("试用 MobX");
console.log(todoStore.report());

todoStore.todos[0].completed = true;
console.log(todoStore.report());

todoStore.todos[1].task = "在自己的项目中试用 MobX";
console.log(todoStore.report());

todoStore.todos[0].task = "理解 MobX 教程";
console.log(todoStore.report());
                        </textarea>
                        <button onClick="runCode(['#code1', '#code2'])" class="btn-run">运行代码</button>

                        <h3>变成响应式</h3>
                        <p>
                            到目前为止，这段代码并没有什么特别之处。但如果我们不用非得刻意调用 <code>report</code> ，而可以规定它必须在每次 <em>相关</em> 状态改变时都被调用呢？那样的话我们就不需要从代码中所有 <em>有可能</em> 对报告产生影响的地方手动调用 <code>report</code> 了。我们确实想让最新的报告被打印出来，但我们并不想因为要手动去组织它而费功夫。
                        </p>
                        <p>
                            幸运的是，这正是 MobX 能为我们做到的事情——自动执行只依赖于状态的代码。这样的话，我们的 <code>report</code> 函数就可以自动更新，就像电子表格里的一个图表一样。为了做到这一点，<code>TodoStore</code> 就必须变成 observable ，这样 MobX 就可以追踪到所有正在进行的更改。为了实现这一点，我们来改一下这个类。
                        </p>
                        <p>
                            还有，<code>completedTodosCount</code> 属性可以从待办清单中被自动派生出来。通过使用 <code>observable</code> 和 <code>computed</code> 注解，我们可以为一个对象引入 observable 属性。在下面的例子里，我们为了刻意地展示出注解而使用了 <code>makeObservable</code> ，但我们其实也可以使用 <code>makeAutoObservable(this)</code> 来简化这个过程。
                        </p>
                        <textarea spellcheck="false" class="prettyprint" id="code3" rows="8">
class ObservableTodoStore {
  todos = [];
  pendingRequests = 0;

  constructor() {
    makeObservable(this, {
      todos: observable,
      pendingRequests: observable,
      completedTodosCount: computed,
      report: computed,
      addTodo: action,
    });
    autorun(() => console.log(this.report));
  }

  get completedTodosCount() {
    return this.todos.filter(
      todo => todo.completed === true
    ).length;
  }

  get report() {
    if (this.todos.length === 0)
      return "<无>";
    const nextTodo = this.todos.find(todo => todo.completed === false);
    return `下一个待办："${nextTodo ? nextTodo.task : "<无>"}"。 ` +
      `进度：${this.completedTodosCount}/${this.todos.length}`;
  }

  addTodo(task) {
    this.todos.push({
      task: task,
      completed: false,
      assignee: null
    });
  }
}

const observableTodoStore = new ObservableTodoStore();
                        </textarea>

                        <p>
                            就是这样！我们把有些属性标记为 <code>observable</code>，以便告诉 Mobx 这些值会随时间的推移而改变。有些值中的 <code>computed</code> 被用来标明这些值能够从状态中派生出来，而且只要底层状态没有发生改变，那么它们还可以从缓存中派生起来。
                        </p>
                        <p>
                            <code>pendingRequests</code> 和 <code>assignee</code> 属性目前还没有用到，但是会在这个教程后面的部分用到的。
                        </p>
                        <p>
                            在构造函数中，我们创建了一个打印 <code>report</code> 的小函数并把它用 <code>autorun</code> 包裹了起来。而 autorun 会创建一个 <em>action</em> ，这个 action 会在小函数用到的任意一个 observable 数据发生改变时自动运行一次。<code>report</code> 会因为使用了 observable 属性 <code>todos</code> 而适时打印出报告。这一点会在下面的列表中展示出来。只需要你按下 <em>运行代码</em> 按钮：
                        </p>

                        <textarea spellcheck="false" class="prettyprint" id="code4" rows="6">
observableTodoStore.addTodo("阅读 MobX 教程");
observableTodoStore.addTodo("试用 MobX");
observableTodoStore.todos[0].completed = true;
observableTodoStore.todos[1].task = "在自己的项目中试用 MobX";
observableTodoStore.todos[0].task = "理解 MobX 教程";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4'])" class="btn-run">运行代码</button>

                        <p>Pure fun, right? The <code>report</code> did print automatically, synchronously and without leaking
                            intermediate values. If you investigate the log carefully, you will see that the fifth line
                            didn't result in a new log-line. Because the report did not <em>actually</em> change as a result
                            of the rename, although the backing data did. On the other hand, changing the name of the first
                            todo did update the report, since that name is actively used in the report.
                            This demonstrates nicely that
                            not just the <code>todos</code> array is being observed by the <code>autorun</code>, but also
                            the individual properties inside the todo items.
                        </p>
                        <h3 id="reactive-reactjs-components">Making React reactive</h3>
                        <p>Ok, so far we made a silly report reactive. Time to build a reactive user interface around this very
                            same store. React components are (despite their name) not reactive out of the box.
                            The <code>observer</code> HoC wrapper from the <code>mobx-react-lite</code> package fixes that by
                            basically wrapping the React component in <code>autorun</code>. To automatically
                            keep components in sync with the state. This is conceptually not different from what we did
                            with the <code>report</code> before.
                        </p>
                        <p>
                            The next listing defines a few React components.
                            The only MobX specific code in there is the <code>observer</code> wrapping.
                            That is enough to make sure that each component individually re-renders when relevant data changes.
                            We don't have to call state <code>useState</code> setters anymore,
                            nor do we have to figure out how to subscribe to the proper parts
                            of the application state using selectors or higher order components that need configuration.
                            Basically, all components have become smart. Yet they are defined in a dumb, declarative manner.
                        </p>
                        <p>
                            Press the <em>运行代码</em> button to see the code below in action. The listing is editable so
                            feel free to play with it. Try for example to remove all the <code>observer</code> calls, or
                            just the one decorating the <code>TodoView</code>. The numbers in the preview on the right highlight
                            how often a component is rendered.
                        </p>
                        <textarea spellcheck="false" class="" id="react1" rows="44">
const TodoList = observer(({store}) => {
  const onNewTodo = () => {
    store.addTodo(prompt('输入新的待办：','请来杯咖啡'));
  }

  return (
    <div>
      { store.report }
      <ul>
        { store.todos.map(
          (todo, idx) => <TodoView todo={ todo } key={ idx } />
        ) }
      </ul>
      { store.pendingRequests > 0 ? <marquee>载入中...</marquee> : null }
      <button onClick={ onNewTodo }>新待办</button>
      <small>（双击待办进行编辑）</small>
      <RenderCounter />
    </div>
  );
})

const TodoView = observer(({todo}) => {
  const onToggleCompleted = () => {
    todo.completed = !todo.completed;
  }

  const onRename = () => {
    todo.task = prompt('任务名称', todo.task) || todo.task;
  }

  return (
    <li onDoubleClick={ onRename }>
      <input
        type='checkbox'
        checked={ todo.completed }
        onChange={ onToggleCompleted }
      />
      { todo.task }
      { todo.assignee
        ? <small>{ todo.assignee.name }</small>
        : null
      }
      <RenderCounter />
    </li>
  );
})

ReactDOM.render(
  <TodoList store={ observableTodoStore } />,
  document.getElementById('reactjs-app')
);
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1'])" class="btn-run">运行代码</button>

                        <p>
                            The next listing nicely demonstrates that we only have to alter the data, without doing any further bookkeeping.
                            MobX will automatically derive and update the relevant parts of the user interface again from the state in the store.
                        </p>

                        <textarea spellcheck="false" class="" id="play1" rows="8">
const store = observableTodoStore;
store.todos[0].completed = !store.todos[0].completed;
store.todos[1].task = "随机待办 " + Math.random();
store.todos.push({ task: "找到一块好奶酪", completed: true });
// 诸如此类...在这里添加你自己的语句
                        </textarea>
                        <button onClick="if (typeof observableTodoStore === 'undefined') { runCode(['#code1', '#code3', '#code4', '#react1']) } runCode(['#play1'])"
                        class="btn-run">运行代码</button>
                        <button id="runline-btn" onClick="runCodePerLine()" class="btn-run">逐行运行</button>
                        <p>&nbsp;</p>

                        <h3>Working with references</h3>
                        <p>
                            So far we have created observable objects (both prototyped and plain objects), arrays and primitives. You might be wondering,
                            how are references handled in MobX? Is my state allowed to form a graph? In the previous listings
                            you might have noticed that there is an <code>assignee</code> property
                            on the todos. Let's give them some values by introducing another &ldquo;store&rdquo; (ok, it's just
                            a glorified array) containing people, and assign tasks to them.
                        </p>
                        <textarea spellcheck="false" class="" id="store2" rows="8">
const peopleStore = observable([
  { name: "Michel" },
  { name: "我" }
]);
observableTodoStore.todos[0].assignee = peopleStore[0];
observableTodoStore.todos[1].assignee = peopleStore[1];
peopleStore[0].name = "Michel Weststrate";
                        </textarea>
                        <button onClick="runCode(['#code1', '#code3', '#code4', '#react1', '#store2'])" class="btn-run">运行代码</button>
                        <p>We now have two independent stores. One with people and one with todos. To assign an <code>assignee</code>
                            to a person from the people store, we just assigned a reference. These changes will be picked
                            up automatically by the <code>TodoView</code>. With MobX there is no need to normalize data first
                            and to write selectors to make sure our components will be updated. In fact, it doesn't even
                            matter where the data is stored. As long as objects are made <em>observable</em>, MobX will be
                            able to track them. Real JavaScript references will just work. MobX will track them automatically
                            if they are relevant for a derivation. To test that, just try changing your name in the next
                            input box (make sure you have pressed the above <em>运行代码</em> button first!).
                        </p>
                        <hr/>
                        <p style="text-align:center">你的名字：
                            <input onkeyup="peopleStore[1].name = event.target.value" />
                        </p>
                        <hr/>
                        <p>By the way, the HTML of the above input box is simply: <pre>&lt;input onkeyup="peopleStore[1].name = event.target.value" /&gt;</pre></p>

                        <h3>Asynchronous actions</h3>
                        <p>Since everything in our small Todo application is derived from the state, it really doesn't matter <em>when</em> state is changed.
                            That makes creating asynchronous actions really straightforward.
                            Just press the the following button (multiple times) to emulate asynchronously loading new todo items:
                        </p>
                        <hr/>
                        <p style="text-align:center">
                            <button onclick="observableTodoStore.pendingRequests++; setTimeout(function() { observableTodoStore.addTodo('随机待办 ' + Math.random()); observableTodoStore.pendingRequests--;  }, 2000);">载入待办</button>
                        </p>
                        <hr/>
                        <p>The code behind that is really straightforward.
                            We start with updating the store property <code>pendingRequests</code> to have the UI reflect the current loading status.
                            Once loading is finished, we update the todos of the store and decrease the <code>pendingRequests</code> counter again.
                            Just compare this snippet with the earlier <code>TodoList</code> definition to see how the pendingRequests property is used.
                        </p><p>
                            Note that the timeout function is wrapped in <code>action</code>. This isn't strictly necessary,
                            but it makes sure that both mutations are processed in a single transaction, making sure any observers are only notified after both updates have completed.
<pre>observableTodoStore.pendingRequests++;
setTimeout(action(() => {
  observableTodoStore.addTodo('随机待办 ' + Math.random());
  observableTodoStore.pendingRequests--;
}), 2000);</pre>
                        </p>

                        <h3>Conclusion</h3>
                        <p>
                            That's all! No boilerplate. Just some simple, declarative components that form our complete UI. And which are derived completely,
                            reactively from our state. You are now ready to start using the <code>mobx</code> and <code>mobx-react-lite</code> packages in your own applications.
                            A short summary of the things you learned so far:
                        </p>
                        <ol>
                            <li>
                                Use the <code>observable</code> decorator or <code>observable(object or array)</code> functions to make objects trackable for MobX.
                            </li>
                            <li>
                                The <code>computed</code> decorator can be used to create functions that can automatically derive value from the state and cache them.
                            </li>
                            <li>
                                Use <code>autorun</code> to automatically run functions that depend on some observable state.
                                This is useful for logging, making network requests, etc.
                            </li>
                            <li>
                                Use the <code>observer</code> wrapper from the <code>mobx-react-lite</code> package to make your React components truly reactive.
                                They will update automatically and
                                efficiently. Even when used in large complex applications with large amounts of data.
                            </li>
                        </ol>
                        <p>
                            Feel free to play around a bit longer with the editable code blocks above to get a basic feeling how MobX reacts to all your
                            changes. You could for example add a log statement to the <code>report</code> function to see when it is called.
                            Or don't show the <code>report</code> at all and see how that
                            influences the rendering of the <code>TodoList</code>. Or show it only under specific circumstances...
                        </p>

                        <h3>MobX doesn't dictate architecture</h3>
                        <p>
                          Please note that the above examples are contrived and it is recommended to use proper engineering practices like
                            encapsulating logic in methods, organize them in stores or controllers, view-models etc.
                            Many different architectural patterns can be applied, and some are further discussed inside the official docs.
                            The above examples, and the examples in the official documentation show how MobX <em>could</em> be used, not how it <em>must</em> be used.
                            Or, as somebody on HackerNews put it:
                            <blockquote><em>
&ldquo;MobX, it's been mentioned elsewhere but I can't help but sing its praises.
Writing in MobX means that using controllers/ dispatchers/ actions/ supervisors or another form of managing dataflow returns to being an architectural concern you can pattern to your application's needs,
rather than being something that's required by default for anything more than a Todo app.&rdquo;
                            </em></blockquote>
                        </p>

                        <div style="text-align:center;">
                            <a class="github-button" href="https://github.com/mobxjs/mobx" data-icon="octicon-star" data-style="small" data-count-href="/mobxjs/mobx/stargazers"
                            data-count-api="/repos/mobxjs/mobx#stargazers_count" data-count-aria-label="# stargazers on GitHub"
                            aria-label="Star mobxjs/mobx on GitHub">Star</a>
                            <a href="https://twitter.com/share" class="twitter-share-button" data-via="mweststrate" data-hashtags="mobx">Tweet</a>
                        </div>

                    </section>

                    <footer>
                        <p class="copyright">MobX 由 <a href="https://twitter.com/mweststrate">mweststrate</a> 维护</p>
                    </footer>
                </div>
              </div>
            </td>
            <td class="right">
                <div class="right-content">
                    <h3>React 预览</h3>
                    <div id="reactjs-app">
                        <p style="text-align: center">读下去并按下你遇到的 <em>运行</em> 按钮！</p>
                    </div>
                    <hr/>
                    <h3>控制台打印
                        <button onclick="clearConsole();" id="clear-btn">清除</button>
                    </h3>
                    <div id="consoleout"></div>
                </div>
            </td>
        </tr>
    </table>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-fork-ribbon-css/0.1.1/gh-fork-ribbon.min.css" />
    <script src="assets/getting-started-assets/javascripts/jquery-2.1.4.min.js"></script>
    <script src="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.js"></script>
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/lib/codemirror.css">
    <link rel="stylesheet" href="assets/getting-started-assets/javascripts/codemirror/theme/xq-light.css">
    <script src="assets/getting-started-assets/javascripts/codemirror/javascript/javascript.js"></script>

    <script src="https://unpkg.com/react@16.13.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16.13.1/umd/react-dom.development.js"></script>
    <script src="assets/getting-started-assets/babel.min.js"></script>
    <script src="https://unpkg.com/mobx@6.0.0-rc.8/dist/mobx.umd.development.js"></script>
    <script src="https://unpkg.com/mobx-react-lite@3.0.0-beta.1/dist/mobxreactlite.umd.development.js"></script>
    <script src="assets/getting-started-assets/script.js"></script>
    <script type="text/javascript">
        var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
        document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
        try {
          var pageTracker = _gat._getTracker("UA-65632006-1");
          pageTracker._trackPageview();
        } catch(err) {}
    </script>
    <script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
    <script>
        !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');
    </script>
</body>

</html>
